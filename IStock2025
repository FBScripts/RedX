if not game:IsLoaded() then
    game.Loaded:Wait()
    print("‚úÖ –ò–≥—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ –∏ ID –∫–∞–Ω–∞–ª–∞
if token == "" or channelId == "" then
    game.Players.LocalPlayer:Kick("‚ùå –í–≤–µ–¥–∏ —Ç–æ–∫–µ–Ω –∏ channelId!")
    return
end

-- Anti-AFK
local VirtualUser = game:GetService('VirtualUser')
game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

-- –§—É–Ω–∫—Ü–∏—è –≤—ã–±–æ—Ä–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
local function selectDevice()
    local DeviceSelectGui = game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("DeviceSelect")
    if DeviceSelectGui then
        local button = DeviceSelectGui.Container.Phone.Button
        local centerX = button.AbsolutePosition.X + button.AbsoluteSize.X/2
        local centerY = button.AbsolutePosition.Y + button.AbsoluteSize.Y/2
        
        game:GetService("VirtualInputManager"):SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
        task.wait(0.1)
        game:GetService("VirtualInputManager"):SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
        print("üì± –í—ã–±—Ä–∞–Ω–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: Phone")
    end
end

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∞–π–ª–æ–≤
local HttpService = game:GetService("HttpService")
if not isfile("user.txt") then writefile("user.txt", "victim_username") end
if not isfile("joined_ids.txt") then writefile("joined_ids.txt", "[]") end

local victimUser = readfile("user.txt")
local joinedIds = HttpService:JSONDecode(readfile("joined_ids.txt"))
local isTeleporting = false

-- –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∫–æ–º–∞–Ω–¥—ã —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
local function findTeleportCommand(content)
    if not content then return nil, nil end
    
    -- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ª—é–±—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
    local patterns = {
        'TeleportService["\'%)]%s*:%s*TeleportToPlacelnstance%s*%(%s*(%d+)%s*,%s*["\']([%w%-]+)["\']',
        'game%s*[:%.]%s*GetService%s*%(%s*["\']TeleportService["\']%s*%)%s*:%s*TeleportToPlacelnstance%s*%(%s*(%d+)%s*,%s*["\']([%w%-]+)["\']',
        'TeleportService["\'%)]%s*:%s*TeleportToPlaceInstance%s*%(%s*(%d+)%s*,%s*["\']([%w%-]+)["\']'
    }
    
    for _, pattern in ipairs(patterns) do
        local placeId, jobId = content:match(pattern)
        if placeId and jobId then
            return placeId, jobId
        end
    end
    
    return nil, nil
end

local lastCheckedMessageId = nil  -- –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è

local function checkDiscord()
    local response = request({
        Url = "https://discord.com/api/v9/channels/"..channelId.."/messages?limit=10",
        Method = "GET",
        Headers = {
            ['Authorization'] = token,
            ['Content-Type'] = 'application/json'
        }
    })

    if not response.Success then
        warn("‚ùå –û—à–∏–±–∫–∞ Discord:", response.StatusCode)
        return false
    end

    local messages = HttpService:JSONDecode(response.Body)
    for _, msg in ipairs(messages) do
        -- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        if lastCheckedMessageId and msg.id == lastCheckedMessageId then
            break
        end

        if msg.content then
            print("üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ:", string.sub(msg.content, 1, 100))
            
            local placeId, jobId = findTeleportCommand(msg.content)
            if placeId and jobId then
                print("üéØ –ù–∞–π–¥–µ–Ω—ã ID:", placeId, jobId)
                
                if not table.find(joinedIds, msg.id) then
                    table.insert(joinedIds, msg.id)
                    writefile("joined_ids.txt", HttpService:JSONEncode(joinedIds))
                    
                    print("üöÄ –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è...")
                    isTeleporting = true
                    lastCheckedMessageId = msg.id  -- –ó–∞–ø–æ–º–∏–Ω–∞–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è
                    
                    local success = pcall(function()
                        game:GetService("TeleportService"):TeleportToPlaceInstance(tonumber(placeId), jobId)
                    end)
                    
                    if not success then
                        isTeleporting = false
                        warn("‚ùå –û—à–∏–±–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏")
                    end
                    return true
                else
                    print("‚ö†Ô∏è –£–∂–µ –±—ã–ª–∏ –Ω–∞ —ç—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–µ")
                end
            end
        end
    end
    
    -- –ó–∞–ø–æ–º–∏–Ω–∞–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏
    if #messages > 0 then
        lastCheckedMessageId = messages[1].id
    end
    
    return false
end

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
while true do
    if not isTeleporting then
        local found = pcall(checkDiscord)
        if not found then
            -- –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∂–¥–µ–º –¥–æ–ª—å—à–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            task.wait(30)
        else
            -- –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —á—Ç–æ-—Ç–æ, —Å–ª–µ–¥—É—é—â—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –¥–µ–ª–∞–µ–º —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
            task.wait(5)
        end
    else
        -- –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏, –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        task.wait(5)
    end
end
